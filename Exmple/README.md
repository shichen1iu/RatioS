# 概览
    RatioS PROGRAM_ID: RSoojvmJQP1NRci479HQHKa4wF6TJKZsb2SZC6tKXFn
    RS提供两个接口,
    1.保险丝
    2.RS_SWAP
    ==============================================================================================
    名字: 保险丝
    收费: 它是永久免费的
    功能: 检测指定ATA账户余额,低于您传递的数量则回滚交易
    场景: 
            当您在套利时,无论使用什么样的方式方法,
            基于算法或是spam,onchain或offchain
            都可以大胆的将min output设置为0,

            保险丝会在链上查询您的 ata_amout 代币余额(后文简称ata_amout),
            再将 ata_amout 和您链下传递的 check_amount 数字类型进行比对
            如果这笔套利tx指令执行到最后 发现执行后的token数量 少于执行前的token数量
            (简单说就是这笔tx做完发现不赚钱麻,管它是小费花多了还是佣金给扣了,都不赚钱就都给我回滚.)
            那么整个tx将被回滚

            如果您有疑问:"那我怎么知道check_amount填多少"
            答:想填多少填多少,这里的逻辑是  if check_amount < ata_mount { rollback(); }
            您可以订阅自己的ata_acount.data.amount,时刻更新ata_mount.

            抽象来说,一次原子套利我不管输入数量是多少,我只需要最后输出大于输入就可以了,过程如何无所谓
            将保险丝ix 作为tx内的最后一个指令 您代码层面的复杂度可以大幅下降

            另外一些场景就是当您使用一些不受信任第三方接口时,
            加一道保险丝可以防呆防作恶(未知接口,只要你signer了,链上是可以修改你的参数的),保护自己wallet的资金
            如果您要保护俩个ATA账户,这时组装两个保险丝ix就行了.

    例子: fuse.ts
    ==============================================================================================
    名字: RS_SWAP
    收费: 260_000 / LAMPORTS = (0.00026/SOL) 
    功能: 当设置的in_amount数量 <= 小于100时, in_amount参数将变成  ATA总量的%进行input, 
         例 17就是ata_amount * 17%,100就是ata_amount,
         当大于100时,和普通swap没有区别
         例 101就是非%的逻辑
    场景: 
            发交易时不知道链上ata的余额,靠%进行完全平仓

    例子: rs_swap.rs( 请先尝试 fuse.ts 一步步来.)

